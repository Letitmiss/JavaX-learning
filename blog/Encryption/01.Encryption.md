# JAVA-Encryption-decryption
JAVA 加密/解密 学习笔记

# 密码分类

1. 对称密码 加密秘钥与解密秘钥相同

2. 非对称密码 加密秘钥与解密秘钥不通，秘钥分为公钥和私钥

3. 分组加密 ：明文分为固定长度的组，同一秘钥对每一块加密，输出固定长度的密文

4. 流密码 ： 序列密码，对明文的的每一位或一个字节加密

6. 散列函数 ： 验证数据的完整性，并不适合解密，单项函数；MD5，SHA，MAC

7. 数字签名：对以数字的形式存储的消息进行处理 


# OSI 安全体系

# JAVA 安全组成
[java安全牛人博客]http://blog.csdn.net/allenwells/article/details/46504383
* JCA Java  Crytography Architecture
* JCE Jvava Crytography Extension
* JSSE Java Secure Socket Extension
* JAAS Authentication and Authentication server

1. Java.security
* 消息摘要
2. javax.crypto
* 安全消息摘要，消息认证鉴别码
3.java.net.ssl
* 安全套接字

## 第三方扩展

* Bouncy Castle
    两种支持方案： 1.配置； 2.调用
* Commons Codec
    1. Apache  
    2. Base64 .二进制,十六进制 
    
# 1.base64应用
# [2.消息摘要算法](https://github.com/Letitmiss/JAVA-Encryption-decryption/blob/master/blog/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.md)
## Base64算法

1. JDK的实现
2. CommonsCodec
````
 public static  void commonsCodecBase64() {
		byte[] encodeBytes = Base64.encodeBase64(SRC.getBytes());
		System.out.println("encode :" + new String(encodeBytes));
		
		byte[] decodeBytes = Base64.decodeBase64(encodeBytes);
		System.out.println("decode :" + new String(decodeBytes));
	}
````
3. Bouncy Castle
````
public static void bouncyCastleBase64 () {
		
		byte[] encodeBytes = org.bouncycastle.util.encoders.Base64.encode(SRC.getBytes());
		System.out.println("encode :" + new String(encodeBytes));
		
		byte[] decodeBytes = org.bouncycastle.util.encoders.Base64.decode(encodeBytes);
		System.out.println("decode :" + new String(decodeBytes));
	}
````
###
```
package com.cong.auth.study;



import java.io.UnsupportedEncodingException;
import java.util.Base64;

/**
 *  Base64 :Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法，而且base64特别适合在http，mime协议下快速传输数据。
 *  MD5
 *  SHA
 *  HMAC
 *  97979797

    01100001 01100001 01100001 01100001

    011000 010110 000101 100001 011000  01  0000

    24 22 5 33 24  补4个0 转化==
     y  W F  h  Y    ==
     YWFhYQ==
 *
 */
public class SecurityBase64 {
     //https://my.oschina.net/benhaile/blog/267738
     //https://blog.csdn.net/weixx3/article/details/81266506
     //https://blog.csdn.net/tomatocc/article/details/77881421
    public static void main(String[] args) throws UnsupportedEncodingException {
        //基础
        byte[] bytes = "aaaa".getBytes("utf-8");
        String encode = Base64.getEncoder().encodeToString("aaaa".getBytes("utf-8"));
        System.out.println(encode);

        byte[] decode = Base64.getDecoder().decode(encode.getBytes("utf-8"));
        String s = new String(decode, "utf-8");
        System.out.println(s);

        //URL编码
        String encode1 = Base64.getUrlEncoder().encodeToString("11/aaa?bb=cc".getBytes("utf-8"));
        System.out.println("encode: " + encode1 );
        byte[] decode1 = Base64.getDecoder().decode(encode1.getBytes("utf-8"));
        System.out.println(new String(decode1,"utf-8"));
    }
}


```

```
package com.cong.auth.study;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

/**
 *  https://blog.csdn.net/u011781521/article/details/77925608 消息摘要算法
 *   16进制 32位
 */
public class SecurityMD5 {

    public static String str = "1234567";
    public static void main(String[] args) throws UnsupportedEncodingException, NoSuchAlgorithmException {
        test1();
    }

    public static void test1 () throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        byte[] digest = md5.digest(str.getBytes("utf-8"));
        String encode = Base64.getEncoder().encodeToString(digest);
        System.out.println(encode);
        String s = new BigInteger(1, digest).toString(16);
        System.out.println(s);

    }
}


package com.cong.auth.study;

import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class SecuritySHA {

    public static String str = "qwertyu";
    public static void main(String[] args) throws UnsupportedEncodingException {
        test1();
        test2();
    }

    public static void test1() throws UnsupportedEncodingException {
        try {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            byte[] digest = sha256.digest(str.getBytes("utf-8"));

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }

    public static void test2() throws UnsupportedEncodingException {
        try {
            MessageDigest sha256 = MessageDigest.getInstance("SHA-512");
            byte[] digest = sha256.digest(str.getBytes("utf-8"));

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
}

package com.cong.auth.study;

import org.springframework.util.StringUtils;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;

/**
 * https://blog.csdn.net/u011781521/article/details/77932321
 */
public class SecurityDES extends Coder {

    public static final String ALGORITHM =  "AES";

    /**
     * 解密
     */
     public static byte[] decrypt(byte[] data, String key) throws Exception {
         //对秘钥处理获得Key对象
         SecretKey secretKey = getSecretKey(key);

         Cipher cipher = Cipher.getInstance(ALGORITHM);
         cipher.init(Cipher.DECRYPT_MODE,secretKey);
         return cipher.doFinal(data);
     }

    private static SecretKey getSecretKey(String key) throws Exception {
        /*DESKeySpec desKeySpec = new DESKeySpec(decryptBASE64(key));
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);
        return keyFactory.generateSecret(desKeySpec);*/
        SecretKeySpec secretKeySpec = new SecretKeySpec(decryptBASE64(key),ALGORITHM);
        return secretKeySpec;
    }

    /**
     * 加密
     */
    public static byte[]  encrypt(String data,String key) throws Exception {
        byte[] bytes = data.getBytes("utf-8");
        SecretKey secretKey = getSecretKey(key);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        return cipher.doFinal(bytes);
    }

    /**
     * 生成秘钥
     * @param
     */
     public static String initKey() throws Exception {
         return initKey(null);
     }

     public static String initKey(String seed) throws Exception {

         SecureRandom secureRandom = null;
         if ( !StringUtils.isEmpty(seed)) {
              secureRandom = new SecureRandom(decryptBASE64(seed));
         } else {
             secureRandom =  new SecureRandom();
         }

         KeyGenerator keyInstance = KeyGenerator.getInstance(ALGORITHM);
         keyInstance.init(secureRandom);
         SecretKey secretKey = keyInstance.generateKey();
         return encryptBASE64(secretKey.getEncoded());
    }

    public static void main(String[] args) throws Exception {
        String input = "aaa";
        String  key = SecurityDES.initKey();
        System.out.println("原文:" + input);
        System.out.println("秘钥:" + key);

        byte[] encrypt = SecurityDES.encrypt(input, key);
        System.out.println("加密后 :" + SecurityDES.encryptBASE64(encrypt)); //

        byte[] decrypt = SecurityDES.decrypt(encrypt, key);
        System.out.println("解密后 :" + new String(decrypt,"utf-8"));
    }
}

package com.cong.auth.study;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;

public class Coder {

    public static final String KEY_SHA = "SHA";
    public static final String KEY_MD5 = "MD5";

    /**
     * MAC算法可选以下多种算法
     * <pre>
     * HmacMD5
     * HmacSHA1
     * HmacSHA256
     * HmacSHA384
     * HmacSHA512
     * </pre>
     */
    public static final String KEY_MAC = "HmacMD5";

    /**
     * BASE64解密
     *
     * @param key
     * @return
     * @throws Exception
     */
    public static byte[] decryptBASE64(String key) throws Exception {
        return (new BASE64Decoder()).decodeBuffer(key);
    }

    /**
     * BASE64加密
     *
     * @param key
     * @return
     * @throws Exception
     */
    public static String encryptBASE64(byte[] key) throws Exception {
        return (new BASE64Encoder()).encodeBuffer(key);
    }

    /**
     * MD5加密
     *
     * @param data
     * @return
     * @throws Exception
     */
    public static byte[] encryptMD5(byte[] data) throws Exception {

        MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);
        md5.update(data);

        return md5.digest();

    }

    /**
     * SHA加密
     *
     * @param data
     * @return
     * @throws Exception
     */
    public static byte[] encryptSHA(byte[] data) throws Exception {

        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);
        return sha.digest(data);

    }

    /**
     * 初始化HMAC密钥
     *
     * @return
     * @throws Exception
     */
    public static String initMacKey() throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);

        SecretKey secretKey = keyGenerator.generateKey();
        return encryptBASE64(secretKey.getEncoded());
    }

    /**
     * HMAC加密
     *
     * @param data
     * @param key
     * @return
     * @throws Exception
     */
    public static byte[] encryptHMAC(byte[] data, String key) throws Exception {

        SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC);
        Mac mac = Mac.getInstance(secretKey.getAlgorithm());
        mac.init(secretKey);

        return mac.doFinal(data);

    }
}



```

